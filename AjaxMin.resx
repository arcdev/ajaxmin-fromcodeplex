<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="CrunchingFile" xml:space="preserve">
    <value>Minifying file '{0}'...</value>
  </data>
  <data name="CrunchingStdIn" xml:space="preserve">
    <value>Minifying from STDIN...</value>
  </data>
  <data name="InvalidArgument" xml:space="preserve">
    <value>Invalid switch: {0}</value>
  </data>
  <data name="InvalidInputEncoding" xml:space="preserve">
    <value>Invalid input encoding name: {0}</value>
  </data>
  <data name="InvalidOutputEncoding" xml:space="preserve">
    <value>Invalid output encoding name: {0}</value>
  </data>
  <data name="InvalidWarningArg" xml:space="preserve">
    <value>Invalid warning level: {0}</value>
  </data>
  <data name="MultipleOutputArg" xml:space="preserve">
    <value>Output file already specified</value>
  </data>
  <data name="NoParsedCode" xml:space="preserve">
    <value>No parsed code block</value>
  </data>
  <data name="OutputArgNeedsPath" xml:space="preserve">
    <value>-O parameter must be followed by output path</value>
  </data>
  <data name="OutputEmpty" xml:space="preserve">
    <value>Minified output is EMPTY!</value>
  </data>
  <data name="SourceFileIsFolder" xml:space="preserve">
    <value>Source file cannot be a folder: {0}</value>
  </data>
  <data name="SourceFileNotExist" xml:space="preserve">
    <value>Source file does not exist: {0}</value>
  </data>
  <data name="ReportUndefinedHeader" xml:space="preserve">
    <value>Undefined Global References:</value>
  </data>
  <data name="InvalidTabSizeArg" xml:space="preserve">
    <value>Invalid Tab Size: {0}</value>
  </data>
  <data name="PrettyAndEchoArgs" xml:space="preserve">
    <value>Pretty-print (-PRETTY) and Echo-input (-ECHO) switches are not compatible</value>
  </data>
  <data name="InputNoPathAttr" xml:space="preserve">
    <value>XML &lt;input&gt; node missing required path attribute</value>
  </data>
  <data name="InputXmlError" xml:space="preserve">
    <value>Error processing input XML: {0}</value>
  </data>
  <data name="MultipleXmlArgs" xml:space="preserve">
    <value>Cannot specify multiple -XML arguments</value>
  </data>
  <data name="NoInput" xml:space="preserve">
    <value>No input files to process</value>
  </data>
  <data name="OutputFileError" xml:space="preserve">
    <value>Output file returned an error code: {0}</value>
  </data>
  <data name="OutputGroupError" xml:space="preserve">
    <value>Output group #{0} returned an error code: {1}</value>
  </data>
  <data name="OutputNoInputNodes" xml:space="preserve">
    <value>Output node contains no input nodes</value>
  </data>
  <data name="XmlArgHasInputFiles" xml:space="preserve">
    <value>Cannot specify -XML argument AND input files</value>
  </data>
  <data name="XmlArgNeedsPath" xml:space="preserve">
    <value>Argument -XML must be followed by XML file path</value>
  </data>
  <data name="XmlInputNotExist" xml:space="preserve">
    <value>XML error: &lt;input&gt; file '{0}' does not exist</value>
  </data>
  <data name="XmlNoOutputNodes" xml:space="preserve">
    <value>Input xml does not contain any &lt;output&gt; nodes</value>
  </data>
  <data name="InvalidSwitchArg" xml:space="preserve">
    <value>Invalid switch argument {0} for switch -{1}</value>
  </data>
  <data name="SwitchRequiresArg" xml:space="preserve">
    <value>Switch -{0} requires an argument</value>
  </data>
  <data name="EncodingArgMustHaveEncoding" xml:space="preserve">
    <value>Encoding switch must be followed by valid encoding name</value>
  </data>
  <data name="ResourceArgInvalidName" xml:space="preserve">
    <value>Resource argument '{0}' must be valid boolean or numeric literal</value>
  </data>
  <data name="Usage" xml:space="preserve">
    <value>Usage:
{0} [-JS [JSOPTS]|-CSS [CSSOPTS]] OPTS* ((IFILE* [-out OFILE])|(-xml XFILE [-out ODIR]))

Valid OPTS are zero or more of:
  -analyze &gt; provide extra analysis output.
  -clobber[:BOOL] &gt; when false, will not overwrite existing output file.
        True always writes output file. Default is false.
  -define:NAME[,NAME]* &gt; add defined case-insensitive names to the list used 
        by the preprocessor.
  -echo &gt; output is an echo of the original input.
  -enc:(in|out) ENC &gt; input or output file text encoding.
  -help &gt; display this usage message.
  -pretty[:N] &gt; causes output to be on multiple lines, with N spaces per tab
        stop. Default N is 4.
  -res[:IDENT] RFILE &gt; use a resource file to specify localization strings
        using non-existent object IDENT, Strings if not specified.
  -silent &gt; silent mode; no error, warning, or message output.
  -term &gt; ensure output ends in semicolon or other valid terminator.
  -warn[:N] &gt; warning level for error messages sent to stderr.
  -? &gt; same as -help.
  
Valid JSOPTS are zero or more of:
  -cc[:BOOL] &gt; turn on or off support for conditional-compilation comments.
        Default is true.
  -comments:(none|important) &gt; whether to remove all comments (none), 
        or preserve important comments. Default is important.
  -debug[:BOOL[,IDENT[.IDENT]*]*] &gt; debug mode does not remove debug 
        statements or function expression names. Default is False (remove).
        Default debug lookups: Debug, $Debug, WAssert, Web.Debug and Msn.Debug.
        To specify debug lookups to remove, add them comma-separated after the
        boolean flag. Specifying lookups on the command line REPLACES the
        defaults; blank lookups are allowed and will be ignored.
  -evals:(ignore|immediate|safeall) &gt; ignore eval statements or ensure that
        that the immediate scope is safe, or all possibly-affected scopes are 
        safe. Default is ignore.
  -fnames:(lock|keep|onlyref) &gt; how to treat function names. Lock does not 
        allow ANY function names to be removed or renamed; keep does not remove
        unreferenced function expression names, but does allow functions to be 
        renamed; onlyref removes unreferenced function expression names and 
        allows all function names to be renamed. Default is onlyref.
  -global:IDENT(,IDENT)* &gt; specify one or more external global variables the
        code references. May be repeated as needed.
  -inline[:BOOL] &gt; whether to make sure strings are safe for HTML inline 
        script. Default is True.
  -literals:(keep|combine, eval|noeval) &gt; two literal treatment options:
        whether to combine duplicate literals or keep them. Default is keep;
        whether to evaluate literal expressions or keep them. Default is eval.
  -mac[:BOOL] &gt; whether to add code to ensure output works in Mac Safari
        browsers. Default is True.
  -new:(keep|collapse) &gt; whether to collapse certain constructors with known
        literals. Default is collapse.
  -rename:(all|localization|none) &gt; automatic local variable and function 
        renaming methodology. Default is all.
  -rename:IDENT=IDENT(,IDENT=IDENT)* &gt; specify one or more comma-separated
        from=to identifier pairs for manual renaming of variables, functions
        or properties. May be repeated as needed.
  -norename:IDENT(,IDENT)* &gt; specify one or more comma-separated identifiers
        that should not be automatically renamed. May be repeated as necessary.
  -rename NFILE &gt; open the XML file with path NFILE and use the &lt;rename&gt;
        elements for manual renaming of variables, function and properties, and
        &lt;norename&gt; elements for excluding identifiers from automatic
        renaming processes. May be repeated as needed.
  -rename:NOPROPS &gt; when using the manual renaming options above, this option
        will turn off property-renaming (renaming only variables and functions).
  -unused:(remove|keep) &gt; whether to keep or remove unused code. Default
        is remove.

Valid CSSOPTS are zero or more of:
  -comments:(none|all|hacks|important) &gt; whether to keep all comments, 
        remove all, keep only the set of supported comment-based hacks, or
        keep only important comments. Default is important.
  -colors:(hex|strict|major) &gt; how to treat color names: always convert to
        hexadecimal values, use strict color names if shorter, or use major-
        browser color names if shorter. Default is strict.

BOOL can be true, false, T, F, Yes, No, Y, or N.
N is a valid non-negative integer.
IDENT is a valid JavaScript identifier (case-sensitive).
NAME is a valid JavaScript identifier (case-insensitive).
ENC is a valid .NET text encoding scheme name (e.g.: UTF-8).
IFILE is a valid path to an existing source file.
OFILE is a valid path to the output file. Existing files will be clobbered
        if the -CLOBBER option is specified.
XFILE is a valid path to an existing XML input file.
ODIR is a valid path to an output folder.
RFILE is a valid path to an existing .RESX or .RESOURCES file.
NFILE is a valid path to an existing XML input file.

XFILE XML format (XML element names and attributes are case-sensitive):
    &lt;root&gt;
      &lt;output path="[OFILE]"&gt;
        &lt;resource path="[RFILE]" name="[IDENT]" /&gt;
        &lt;input path="[IFILE]" /&gt;
      &lt;/output&gt;
    &lt;/root&gt;
  Must have one or more &lt;output&gt; nodes.
  Each &lt;output&gt; node must have one or more &lt;input&gt; nodes and a
       single optional &lt;resource&gt; node.
  Attribute 'path' is optional for &lt;output&gt; nodes; required for
       &lt;input&gt; and &lt;resource&gt; nodes.
       
NFILE XML format (XML element names and attributes are case-sensitive):
    &lt;root&gt;
      &lt;rename from="[IDENT]" to="[IDENT]" /&gt;
      &lt;norename id="[IDENT]" /&gt;
    &lt;/root&gt;
  File can contain any number of &lt;rename&gt; or &lt;norename&gt; elements.
  Each &lt;rename&gt; element must have both from and to attributes.
  Each &lt;norename&gt; element must have an id attribute.
  All [IDENT] values must be valid JavaScript identifiers.
  
Everything is case-insensitive unless otherwise noted.
If no OFILE specified, output sent to STDOUT.
If no IFILE and no XFILE, input comes from STDIN.
If input comes from STDIN, -JS or -CSS option must be specified.
Multiple IFILE files will be concatenated to the output.</value>
  </data>
  <data name="ResourceArgNeedsPath" xml:space="preserve">
    <value>-RES parameter must be followed by path to existing resource file</value>
  </data>
  <data name="ReadingResourceFile" xml:space="preserve">
    <value>Processing resource script {0}...</value>
  </data>
  <data name="ResourceNoPathAttr" xml:space="preserve">
    <value>XML &lt;resource&gt; node missing required path attribute</value>
  </data>
  <data name="XmlResourceNotExist" xml:space="preserve">
    <value>XML error: &lt;resource&gt; file '{0}' does not exist</value>
  </data>
  <data name="MultipleResourceArgs" xml:space="preserve">
    <value>Cannot specify multiple -RES arguments</value>
  </data>
  <data name="ResourceArgInvalidType" xml:space="preserve">
    <value>Invalid resource file type: {0}. Must be .JS, .RESX, or .RESOURCES.</value>
  </data>
  <data name="OutputFileErrorSubCat" xml:space="preserve">
    <value>output file</value>
  </data>
  <data name="OutputGroupErrorSubCat" xml:space="preserve">
    <value>output group</value>
  </data>
  <data name="ConflictingInputType" xml:space="preserve">
    <value>Conflicting input type switches or input file extensions (JS and CSS)</value>
  </data>
  <data name="UnknownInputType" xml:space="preserve">
    <value>Unknown input type. Please use either the -JS or -CSS switch.</value>
  </data>
  <data name="NoClobberError" xml:space="preserve">
    <value>File already exists and clobber option is not set to true. Output not created: {0}</value>
  </data>
  <data name="SavingsGzipMessage" xml:space="preserve">
    <value>Gzip of output approximately {0} bytes ({1}% compression)</value>
  </data>
  <data name="SavingsMessage" xml:space="preserve">
    <value>Original Size: {0} bytes; reduced size: {1} bytes ({2}% minification)</value>
  </data>
  <data name="SavingsOutputMessage" xml:space="preserve">
    <value>Output size: {0} bytes</value>
  </data>
  <data name="InvalidKillSwitchArg" xml:space="preserve">
    <value>Invalid kill switch value: '{0}' must be a valid decimal number</value>
  </data>
  <data name="RenameArgMissingParameterOrFilePath" xml:space="preserve">
    <value>Rename switch must either have valid parameter parts or be followed by valid file path</value>
  </data>
  <data name="InvalidRenameIdentifiers" xml:space="preserve">
    <value>Rename identifier switch must have valid 'from' and 'to' identifiers: '{0}' and '{1}' are both invalid JavaScript identifiers.</value>
  </data>
  <data name="InvalidRenameFromIdentifier" xml:space="preserve">
    <value>Rename identifier switch must have valid 'from' identifier: '{0}' is an invalid JavaScript identifier.</value>
  </data>
  <data name="InvalidRenameToIdentifier" xml:space="preserve">
    <value>Rename identifier switch must have valid 'to' identifier: '{0}' is an invalid JavaScript identifier.</value>
  </data>
  <data name="AnonymousNameFormat" xml:space="preserve">
    <value>anonymous_{0}</value>
  </data>
  <data name="ReportBindingFormat" xml:space="preserve">
    <value>    {0} [{1}], {3}, {2} reference(s){4}</value>
  </data>
  <data name="ReportBindingRefCount" xml:space="preserve">
    <value>, {0} reference(s)</value>
  </data>
  <data name="ReportBindingRenamed" xml:space="preserve">
    <value>, renamed to "{0}"</value>
  </data>
  <data name="ReportCatchEnvironment" xml:space="preserve">
    <value>Catch Environment {0}</value>
  </data>
  <data name="ReportCategoryArgument" xml:space="preserve">
    <value>Argument</value>
  </data>
  <data name="ReportCategoryArguments" xml:space="preserve">
    <value>Arguments Object</value>
  </data>
  <data name="ReportCategoryCatchArgument" xml:space="preserve">
    <value>Catch Error Object</value>
  </data>
  <data name="ReportCategoryFunction" xml:space="preserve">
    <value>Function</value>
  </data>
  <data name="ReportCategoryNamedFunctionExpression" xml:space="preserve">
    <value>Function Expression</value>
  </data>
  <data name="ReportCategoryPredefined" xml:space="preserve">
    <value>Predefined</value>
  </data>
  <data name="ReportCategoryProperty" xml:space="preserve">
    <value>Property</value>
  </data>
  <data name="ReportCategoryUndefined" xml:space="preserve">
    <value>UNDEFINED</value>
  </data>
  <data name="ReportCategoryVariable" xml:space="preserve">
    <value>Variable</value>
  </data>
  <data name="ReportDefinedLocation" xml:space="preserve">
    <value>defined at {0}</value>
  </data>
  <data name="ReportFunctionHeader" xml:space="preserve">
    <value>Function {1} {0} {2}{3}{4}</value>
  </data>
  <data name="ReportGlobalEnvironment" xml:space="preserve">
    <value>Global Environment {0}</value>
  </data>
  <data name="ReportLexDefines" xml:space="preserve">
    <value>  Defines:</value>
  </data>
  <data name="ReportLexNoDefines" xml:space="preserve">
    <value>  No definitions.</value>
  </data>
  <data name="ReportLexNoReferences" xml:space="preserve">
    <value>  No References.</value>
  </data>
  <data name="ReportLexReferences" xml:space="preserve">
    <value>  References:</value>
  </data>
  <data name="ReportLexUnknown" xml:space="preserve">
    <value>  STATIC UNKNOWN (automatic renaming disabled)</value>
  </data>
  <data name="ReportLexUnresolvedReference" xml:space="preserve">
    <value>    {0} unresolved reference at {1}</value>
  </data>
  <data name="ReportNoLocation" xml:space="preserve">
    <value>defined at (?)</value>
  </data>
  <data name="ReportReferenceFormat" xml:space="preserve">
    <value>    {0}{4} [{3}{1}] {2}</value>
  </data>
  <data name="ReportReferenceInner" xml:space="preserve">
    <value />
  </data>
  <data name="ReportReferenceOuter" xml:space="preserve">
    <value>Outer </value>
  </data>
  <data name="ReportReferenceRenamed" xml:space="preserve">
    <value> ({0})</value>
  </data>
  <data name="ReportUndefinedBinding" xml:space="preserve">
    <value>    {0} at {1}</value>
  </data>
  <data name="ReportUndefinedNone" xml:space="preserve">
    <value>    None</value>
  </data>
  <data name="ReportUnknownEnvironment" xml:space="preserve">
    <value>Unknown Environment {0}</value>
  </data>
  <data name="ReportWithEnvironment" xml:space="preserve">
    <value>With Environment {0}</value>
  </data>
  <data name="ReportReferenceProperty" xml:space="preserve">
    <value>    {0}{1} [{2}] or reference to [{3}] {4}</value>
  </data>
  <data name="ReportReferencePropertyUnresolved" xml:space="preserve">
    <value>    {0}{1} [{2}] or unresolved global reference</value>
  </data>
  <data name="ReportLexStrict" xml:space="preserve">
    <value>  Strict-mode</value>
  </data>
</root>